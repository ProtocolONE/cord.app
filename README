Необходимо ПО и библиотеки.
1. QT SDK версии 4.8 (http://qt.nokia.com/downloads)
2. Visual Leak Detector for Visual C++ (http://vld.codeplex.com/releases) для сборки проекта в DEBUG режиме*.
3. Visual Studion 2010.
4. Google Test SDK 1.6.0 (http://code.google.com/p/googletest/downloads/list). По умолчанию SDK расположено
   в Common\Google\GTest\1.6.0\                                                                            
      
Подготовка к работе. 
1. Убедитесь, что переменная среды окружения** VLDDIR указывает в корневую папку библиотеки Visual Leak Detector.
2. Убедитесь, что переменная среды окружения QTDIR указывает на SDK QT соотвествующей версии компилятора 
   Visual Studio*** 
3. Убедитесь, что переменная среды окружения QGNACOMMONDIR и GnaCommonLibs - Путь в папку куда будут копировать себя основные 
	библиотеки после сборки.
4. Переменная окружения QGNAQMLDIR указывает на корневую папку с QML для qGNA
4. Переменная окружения QCSQMLDIR указывает на корневую папку с QML для qCS
	
* Проверка мемори ликов включается через дефайн VLD_CHECK_ENABLED

** Во всех указанных в данном документе переменных среды окружения нельяз указывать закрывающие слыши.

*** $(DefaultQtDir) используется для определение месторасположения библиотеки QT. 
Для сборки этого проекта должна быть указана версия 4.8.
Если вы правильно установили эту переменную в Qt->Qt Options->Qt Versions
то переменная QTDIR (путь в корень папки Qt.) будет автоматически установлена.
Установите переменную QTDIR если вы руками устанавливали библиотеки Qt.

Важно:
1. Никогда не редактируйте и не сохраняйте ресурсный файл проекта из студии.



QGNA Project Guide
--------------------------------------
0) Общие требования
	Информация о файловой структуре и ссылки на  принятых стиль кодирования доступны на корпоративной вики в разделе `QGNA C++ Code Style Guide`: http://goo.gl/yYYqg
	
	Для быстрого ознакомления. 
	Стиль кодирования:	
		http://wiki.qt-project.org/Coding_Style
		http://wiki.qt-project.org/Coding_Conventions
		http://wiki.qt-project.org/API_Design_Principles
		http://wiki.qt-project.org/Binary_Compatibility_Workarounds
		http://wiki.qt-project.org/Branch_Guidelines
    
	Структура папок:
  
		Components - сожержит исходный код различным компонентов системы
			-->ComponentName
				-->trunk
					-->ComponentName
						-->lib - содержит lib библиотеки проекта, не относящие к Common компонентам
						-->src - содержит симметричные .cpp файлы проекта
							-->ComponentName
								-->folder1/
									*.cpp
									*.cpp
						-->include - содержит .h файлы проекта
							-->ComponentName
								-->folder1
									*.h
									*.h
						--i18n - содержит локализационные файлы проекта
						ComponentName.proj
					-->ComponentNameTest - файловая структура теста является зеркальным отражением фаловой структуры ComponentName
						-->src
							-->folder1/
								*.cpp
						-->include
							-->folder1
								*.h
						ComponentNameTest.proj
					ComponentName.sln
					README - краткое описание компонента или ссылки на соотвествующие разделы документации, особенности использования или установки
   
    Именование бинарников:
		ComponentNameX64.lib - библиотека для x64 архитектуры, 
		ComponentNameX64d.lib - отладочная библиотека для x64 архитектуры,
		ComponentNameX86.lib - библиотека для x86 архитектуры, 
		ComponentNameX86d.lib - отладочная библиотека для x86 архитектуры,
		ComponentNameX64.dll
		ComponentNameX64d.dll
		ComponentNameX86.dll
		ComponentNameX86d.dll
   
	Во всех файлах проекта (кроме автогенерируемых) вы обязаны использовать следующий заголовок:
	
	/****************************************************************************
	** This file is a part of Syncopate Limited GameNet Application or it parts.
	**
	** Copyright (©) 2011 - 2012, Syncopate Limited and/or affiliates. 
	** All rights reserved.
	**
	** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
	** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
	****************************************************************************/
   
1) Общие компоненты

	Папка Common содержит общие для всех компонентов и приложений библиотеки и заголовочные файлы. Любые библиотеки
	сторонних вендоров или компоненты, используемые в QGNA должны хранится в этой папке. 

	Её структра (по возможности для внешних вендоров и обязательно для GGS компонентов):
		Common
			-->Имя правообладателя 
				-->Название библиотеки
					-->Версия библиотеки
						-->include
							-->Название библиотеки
								-->имя.h
								-->имя (для генерации файлов воспользуйтесь incgen.cmd из папки Etc)
						-->bin
						-->lib
						-->pdb  
						-->...

	Использование дополнительного уровня вложенности для заголовочных файлов обуславливается необходимостью
	явного разделения заголовочных файлов компонентов, т.е. вместо 
		#include "ComponentHelper.h" 
	пишется
		#include <ComponentName\ComponentHelper> 

	Это позволяет избежать конфликтов по именам и явно декларировать необходимые библиотеки для сборки проекта, 
	т.к. ComponentName сразу же виден в коде.

2) Подключение общих компонентов и возврат собранных бинарников в общие компоненты
	
	В проекте, экспортирующем свои файлы в Common должен содержаться Property файл Deploy.props.
	Создайте файл в корне вашего проекта (там где лежит sln) следующего содержимого:	

			<?xml version="1.0" encoding="utf-8"?>
			<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
			  <ImportGroup Label="PropertySheets" />
			  <PropertyGroup Label="UserMacros">
				<CommonArea>trunk</CommonArea>
			  </PropertyGroup>
			  <PropertyGroup />
			  <ItemDefinitionGroup />
			  <ItemGroup>
				<BuildMacro Include="CommonArea">
				  <Value>$(CommonArea)</Value>
				  <EnvironmentVariable>true</EnvironmentVariable>
				</BuildMacro>
			  </ItemGroup>
			</Project>
			
	Добавьте его к проекту в студии View->Other Window->Property Manager->Add Existing Property Sheet 
	Добавьте его к Solution Items (там же где Readme.txt)
	
	Вы можете самостоятельно изменить значение CommonArea - тем самым вы выбираете другой путь для копирования
	файлов в post-build event*	
	Важно, что сборочная машина заменит то, что вы напишите на выражение указанное в задаче.
	При необходимости вы можете добавить любые дополнительные значения по своему желанию.
	
	Для подключения компонентов вы должны указать
		$(QGNACOMMONDIR)\Google\gtest\1.6.0\include
		$(QGNACOMMONDIR)\GGS\RestAPI\trunk\lib

	Скопировать внешние бинарные зависимости
		xcopy /Y /I /R "$(QGNACOMMONDIR)\Haxx\Curl\7.24.0\bin\*.dll" "$(TargetDir)"

	*Скопировать результат сборки в Common
		IF NOT "$(QGNACOMMONDIR)"=="" (
			xcopy /Y /I /R "$(TargetDir)*.dll" "$(QGNACOMMONDIR)\GGS\$(SolutionName)\$(CommonArea)\bin"
			xcopy /Y /I /R "$(TargetDir)*.lib" "$(QGNACOMMONDIR)\GGS\$(SolutionName)\$(CommonArea)\lib"
			xcopy /Y /I /R "$(TargetDir)*.pdb" "$(QGNACOMMONDIR)\GGS\$(SolutionName)\$(CommonArea)\pdb"
			xcopy /Y /I /R /E "$(ProjectDir)include\*.h" "$(QGNACOMMONDIR)\GGS\$(SolutionName)\$(CommonArea)\include\"
			xcopy /Y /I /R /E "$(ProjectDir)include\*" "$(QGNACOMMONDIR)\GGS\$(SolutionName)\$(CommonArea)\include\"
            xcopy /Y /I /R /E "$(ProjectDir)i18n\*" "$(QGNACOMMONDIR)\GGS\$(SolutionName)\$(CommonArea)\i18n"
		) else (
			ECHO QGNACOMMONDIR not defined!
			EXIT /B 1
		)

	Не используйте pragma lib - вы разносите информацию по требуемым libs между проектом и 
	исходным кодом и затрудняете понимание необходимых lib для сборки. Прописывайте используемые библиотеки в проекте.

2.1) Локализация

	Важно! Обратите внимание, что вы руками должны создать папку i18n
	
	Именование идентификаторов:
	- идентификаторы записываются в верхнем регистре
	- разделитель знак подчеркивания "_"  
	- использовать смысловые префиксы MSG, TITLE, PHOLDER (PLACEHOLDER), INPUT (INPUT TEXT), ERROR, WARNING, INFO, и т.п.
		
	Используйте следующие команды для создание файлов локализации
		$(QTDIR)\bin\lupdate.exe "$(ProjectDir)\." -ts "$(ProjectDir)\i18n\$(ProjectName)_<lang_name>.ts"
	
	По умолчанию вы должны использовать в Pre Build Events:
		$(QTDIR)\bin\lupdate.exe "$(ProjectDir)\." -ts "$(ProjectDir)\i18n\$(ProjectName)_ru.ts"
		$(QTDIR)\bin\lupdate.exe "$(ProjectDir)\." -ts "$(ProjectDir)\i18n\$(ProjectName)_en.ts"
	
	Для непереведенных в лингвисте фраз используйте текст `TRANSLATE_ME`.
	
	После сборки вы должны открыть лингвист и ввесте перевод для фраз.

				
	
3) Создание новых компонентов.

3.1) Добавление версии.

Создайте ресурсный файл с секцией VERSION и замените её на следующую

#include "version.h"
VS_VERSION_INFO VERSIONINFO
 FILEVERSION FILEVER
 PRODUCTVERSION PRODUCTVER
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "041904b0"
        BEGIN
            VALUE "CompanyName", COMPANYNAME
            VALUE "FileDescription", FILEDESCRIPTION
            VALUE "FileVersion", STRFILEVER
            VALUE "InternalName", INTERNALNAME
            VALUE "LegalCopyright", LEGALCOPYRIGHT
            VALUE "OriginalFilename", ORIGINALFILENAME
            VALUE "ProductName", PRODUCTNAME 
            VALUE "ProductVersion", STRPRODUCTVER
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x419, 1200
    END
END

Создайте в корне проекта version.h со следующим содержимым:

/****************************************************************************
** This file is a part of Syncopate Limited GameNet Application or it parts.
**
** Copyright (©) 2011 - 2012, Syncopate Limited and/or affiliates. 
** All rights reserved.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
****************************************************************************/

#ifndef _GGS_RESTAPI_VERSION_H_
#define _GGS_RESTAPI_VERSION_H_

#ifndef HUDSON_BUILD
    #define FILEVER          1,0,0,0
    #define PRODUCTVER       FILEVER
    #define STRFILEVER       "1,0,0,0"
    #define STRPRODUCTVER    STRFILEVER

    #define COMPANYNAME      "GGS"
    #define FILEDESCRIPTION  "Developer version of GameNet RestApi library"
    #define INTERNALNAME     "RestApi"
    #define LEGALCOPYRIGHT   "Copyright(c) 2010 - 2012"

    #ifdef DEBUG 
        #define ORIGINALFILENAME "RestApiX86d.dll"
    #else
        #define ORIGINALFILENAME "RestApiX86.dll"
    #endif

    #define PRODUCTNAME      "GameNet RestAPI library"
#else
    #define FILEVER          $$MAJOR$$,$$MINOR$$,$$HUDSON_BUILD$$,$$SVN_REVISION$$
    #define PRODUCTVER       FILEVER
    #define STRFILEVER       "$$MAJOR$$,$$MINOR$$,$$HUDSON_BUILD$$,$$SVN_REVISION$$"
    #define STRPRODUCTVER    STRFILEVER

    #define COMPANYNAME      "$$COMPANYNAME$$"
    #define FILEDESCRIPTION  "$$FILEDESCRIPTION$$"
    #define INTERNALNAME     "$$INTERNALNAME$$"
    #define LEGALCOPYRIGHT   "$$LEGALCOPYRIGHT$$"
    #define ORIGINALFILENAME "$$FILENAME$$"
    #define PRODUCTNAME      "$$PRODUCTNAME$$"
#endif

#endif //_GGS_RESTAPI_VERSION_H_

Замените описание компонента для dev версии.

3.2) Включайте Generate Debug Info для релиз версий в больших / мало автотестируемых компонентах или
     в случае, если с продакшена валятся непонятные дампы по компоненту!

4.0) Полезные дефайны очень желательны к использованию.

Проверка на успешное подключение к сигналу:
#define SIGNAL_CONNECT_CHECK(X) { bool result = X; Q_ASSERT_X(result, __FUNCTION__ , #X); }

Пример использования:
SIGNAL_CONNECT_CHECK(QObject::connect(obj, SIGNAL(progressChanged()), this, SLOT(progressChanged())));

Вывод логов:
#define CRITICAL_LOG qCritical() << __FILE__ << __LINE__ << __FUNCTION__
#define WARNING_LOG qWarning() << __FILE__ << __LINE__ << __FUNCTION__
#define DEBUG_LOG qDebug() << __FILE__ << __LINE__ << __FUNCTION__

Пример:
WARNING_LOG << "HDD is broken.";


5.0) Использование Symbol Server 
Текущий сервер: \\symbolserver\symbols

Сервер надо прописать в студии в закладке:
Debug\Options and Settings\
В ней выбираем подпапдку Symbols и в поле Cache symbols in this directory: пишем адрес до текущего сервера (т.е. \\symbolserver\symbols)

Дальше в этих же настройках, в папке General ставим галку рядом с опцией "Enable source server support"
  
5.1) Настрйка сборочной машины.
Ставим WinSdk в нем при установке выбираем Debugging Tools
Он обычно ставиться в C:\Program Files\Debugging Tools for Windows (x64)

Добавляем в переменную PATH
C:\Program Files\Debugging Tools for Windows (x64)
и C:\Program Files\Debugging Tools for Windows (x64)\srcsrv

После сборки добавляем шаг
ssindex.cmd -system=svn -symbols="%WORKSPACE%\!build\%PROJECT_NAME%\" -source="%WORKSPACE%" /debug

И добавляем ЕЩЕ один шаг (нельзя в 1 совместить)
set PDBDIRECTORY=\\symbolserver\symbols
for /f %%V in ('time /t') do (set TM=%%V)
set DT=%date:~6,4%%date:~3,2%%date:~0,2%-%TM:~0,2%%TM:~3,2%
symstore add /r /f "%WORKSPACE%\!build\%PROJECT_NAME%\*.*" /s %PDBDIRECTORY% /t "%PROJECT_NAME%" /v "Build %MAJOR%.%MINOR%.%BUILD_NUMBER%.%SVN_REVISION%" /c "%DT% Daily Build"











